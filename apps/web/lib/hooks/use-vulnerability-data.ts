import * as React from "react";
import { useQuery } from "@tanstack/react-query";
import { CisaKev } from "@/lib/types";

// Global cache for vulnerability data
const vulnerabilityCache = new Map<
  string,
  {
    data: any[];
    timestamp: number;
    loading: boolean;
    promise?: Promise<any>;
  }
>();

// Cache duration: 5 minutes
const CACHE_DURATION = 5 * 60 * 1000;

// In-flight requests to prevent duplicates
const inflightRequests = new Map<string, Promise<any>>();

interface VulnerabilityDataResult {
  data: any[];
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

// Generate cache key from parameters
function getCacheKey(dateFrom: string, dateTo: string, limit: number): string {
  return `${dateFrom}-${dateTo}-${limit}`;
}

// Check if cached data is still valid
function isCacheValid(cacheEntry: { timestamp: number }): boolean {
  return Date.now() - cacheEntry.timestamp < CACHE_DURATION;
}

// Fetch vulnerability data with caching and deduplication
async function fetchVulnerabilityData(
  dateFrom: string,
  dateTo: string,
  limit: number = 50
): Promise<any[]> {
  const cacheKey = getCacheKey(dateFrom, dateTo, limit);

  // Check if request is already in flight
  if (inflightRequests.has(cacheKey)) {
    return inflightRequests.get(cacheKey)!;
  }

  // Check cache first
  const cached = vulnerabilityCache.get(cacheKey);
  if (cached && isCacheValid(cached)) {
    return cached.data;
  }

  // Make the API request
  const requestPromise = (async () => {
    try {
      const params = new URLSearchParams({
        dateFrom,
        dateTo,
        limit: Math.min(limit, 100).toString(), // Ensure we don't exceed API limit
        sortBy: "dateAdded",
        sortOrder: "desc",
      });

      const response = await fetch(`/api/vulnerabilities/cisa?${params}`);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          errorData.error || `API responded with status: ${response.status}`
        );
      }

      const result = await response.json();
      const data = result.data || [];

      // Update cache
      vulnerabilityCache.set(cacheKey, {
        data,
        timestamp: Date.now(),
        loading: false,
      });

      return data;
    } catch (error) {
      // Remove from cache on error
      vulnerabilityCache.delete(cacheKey);
      throw error;
    } finally {
      // Remove from in-flight requests
      inflightRequests.delete(cacheKey);
    }
  })();

  // Store in-flight request
  inflightRequests.set(cacheKey, requestPromise);

  return requestPromise;
}

interface UseVulnerabilityDataOptions {
  dataSource?: "cisa" | "nvd" | "mitre";
  enabled?: boolean;
}

export function useVulnerabilityData({
  dataSource,
  enabled = true,
}: UseVulnerabilityDataOptions) {
  const endpoint = `/api/vulnerabilities/${dataSource}`;

  return useQuery<CisaKev[]>({
    queryKey: ["vulnerabilities", dataSource],
    queryFn: async () => {
      const response = await fetch(endpoint);
      const result = await response.json();
      if (!result.success) {
        throw new Error(result.error || "Failed to fetch vulnerability data");
      }
      return result.data || [];
    },
    enabled: !!dataSource && enabled,
  });
}

// Hook for fetching all vulnerabilities on a specific date
export function useVulnerabilityDataForDate(
  date: string | null,
  enabled: boolean = true
) {
  // We can reuse the main hook and filter the data on the client-side.
  // TanStack Query's caching makes this efficient.
  const { data, isLoading, error } = useVulnerabilityData({
    dataSource: "cisa", // Assuming this is for CISA KEVs
    enabled: !!date && enabled,
  });

  const filteredData = React.useMemo(() => {
    if (!data || !date) return [];
    const targetDate = new Date(date);
    return data.filter((vuln) => {
      const vulnDate = new Date(vuln.dateAdded);
      return (
        vulnDate.getFullYear() === targetDate.getFullYear() &&
        vulnDate.getMonth() === targetDate.getMonth() &&
        vulnDate.getDate() === targetDate.getDate()
      );
    });
  }, [data, date]);

  return { data: filteredData, isLoading, error };
}

// Utility to clear all cached data
export function clearVulnerabilityCache(): void {
  vulnerabilityCache.clear();
  inflightRequests.clear();
}

// Utility to get cache stats for debugging
export function getVulnerabilityCacheStats() {
  return {
    cacheSize: vulnerabilityCache.size,
    inflightRequests: inflightRequests.size,
    cacheKeys: Array.from(vulnerabilityCache.keys()),
  };
}
