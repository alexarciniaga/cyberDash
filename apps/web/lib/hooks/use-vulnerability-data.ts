import * as React from "react";

// Global cache for vulnerability data
const vulnerabilityCache = new Map<
  string,
  {
    data: any[];
    timestamp: number;
    loading: boolean;
    promise?: Promise<any>;
  }
>();

// Cache duration: 5 minutes
const CACHE_DURATION = 5 * 60 * 1000;

// In-flight requests to prevent duplicates
const inflightRequests = new Map<string, Promise<any>>();

interface VulnerabilityDataResult {
  data: any[];
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

// Generate cache key from parameters
function getCacheKey(dateFrom: string, dateTo: string, limit: number): string {
  return `${dateFrom}-${dateTo}-${limit}`;
}

// Check if cached data is still valid
function isCacheValid(cacheEntry: { timestamp: number }): boolean {
  return Date.now() - cacheEntry.timestamp < CACHE_DURATION;
}

// Fetch vulnerability data with caching and deduplication
async function fetchVulnerabilityData(
  dateFrom: string,
  dateTo: string,
  limit: number = 50
): Promise<any[]> {
  const cacheKey = getCacheKey(dateFrom, dateTo, limit);

  // Check if request is already in flight
  if (inflightRequests.has(cacheKey)) {
    return inflightRequests.get(cacheKey)!;
  }

  // Check cache first
  const cached = vulnerabilityCache.get(cacheKey);
  if (cached && isCacheValid(cached)) {
    return cached.data;
  }

  // Make the API request
  const requestPromise = (async () => {
    try {
      const params = new URLSearchParams({
        dateFrom,
        dateTo,
        limit: Math.min(limit, 100).toString(), // Ensure we don't exceed API limit
        sortBy: "dateAdded",
        sortOrder: "desc",
      });

      const response = await fetch(`/api/vulnerabilities/cisa?${params}`);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          errorData.error || `API responded with status: ${response.status}`
        );
      }

      const result = await response.json();
      const data = result.data || [];

      // Update cache
      vulnerabilityCache.set(cacheKey, {
        data,
        timestamp: Date.now(),
        loading: false,
      });

      return data;
    } catch (error) {
      // Remove from cache on error
      vulnerabilityCache.delete(cacheKey);
      throw error;
    } finally {
      // Remove from in-flight requests
      inflightRequests.delete(cacheKey);
    }
  })();

  // Store in-flight request
  inflightRequests.set(cacheKey, requestPromise);

  return requestPromise;
}

// Hook for fetching all vulnerabilities in a date range
export function useVulnerabilityData(
  dateFrom: string | null,
  dateTo: string | null,
  limit: number = 50
): VulnerabilityDataResult {
  const [data, setData] = React.useState<any[]>([]);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  const cacheKey = React.useMemo(() => {
    if (!dateFrom || !dateTo) return null;
    return getCacheKey(dateFrom, dateTo, limit);
  }, [dateFrom, dateTo, limit]);

  const fetchData = React.useCallback(async () => {
    if (!dateFrom || !dateTo || !cacheKey) {
      setData([]);
      setLoading(false);
      setError(null);
      return;
    }

    // Check cache first for immediate response
    const cached = vulnerabilityCache.get(cacheKey);
    if (cached && isCacheValid(cached)) {
      setData(cached.data);
      setLoading(false);
      setError(null);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const result = await fetchVulnerabilityData(dateFrom, dateTo, limit);
      setData(result);
    } catch (err) {
      console.error("Failed to fetch vulnerability data:", err);
      setError(
        err instanceof Error
          ? err.message
          : "Failed to fetch vulnerability data"
      );
      setData([]);
    } finally {
      setLoading(false);
    }
  }, [dateFrom, dateTo, limit, cacheKey]);

  // Fetch data when parameters change
  React.useEffect(() => {
    fetchData();
  }, [fetchData]);

  const refetch = React.useCallback(() => {
    // Clear cache for this key and refetch
    if (cacheKey) {
      vulnerabilityCache.delete(cacheKey);
    }
    fetchData();
  }, [cacheKey, fetchData]);

  return { data, loading, error, refetch };
}

// Hook for fetching vulnerabilities for a specific date (used for hover)
export function useVulnerabilityDataForDate(
  date: string | null,
  enabled: boolean = true
): VulnerabilityDataResult {
  const dateFrom = React.useMemo(() => {
    if (!date) return null;
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    return d.toISOString();
  }, [date]);

  const dateTo = React.useMemo(() => {
    if (!date) return null;
    const d = new Date(date);
    d.setHours(23, 59, 59, 999);
    return d.toISOString();
  }, [date]);

  return useVulnerabilityData(
    enabled ? dateFrom : null,
    enabled ? dateTo : null,
    50
  );
}

// Utility to clear all cached data
export function clearVulnerabilityCache(): void {
  vulnerabilityCache.clear();
  inflightRequests.clear();
}

// Utility to get cache stats for debugging
export function getVulnerabilityCacheStats() {
  return {
    cacheSize: vulnerabilityCache.size,
    inflightRequests: inflightRequests.size,
    cacheKeys: Array.from(vulnerabilityCache.keys()),
  };
}
